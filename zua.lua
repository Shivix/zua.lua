#!/usr/bin/env lua

DATA_FILE = os.getenv("ZUA_DATA_FILE") or "~/.local/state/zua/data"
DATA_FILE = DATA_FILE:gsub("^~", assert(os.getenv("HOME")))

local options = {
    help = {
        short = "h",
    },
    version = {
        short = "v",
    },
    patternmatch = {
        short = "p",
    },
    case = {
        short = "c",
    },
    name = {
        short = "n",
        value = true,
    },
    nojump = {
        short = "N",
    },
}

local version = "1.4.1"
local help_msg = [[
zua.lua ]] .. version .. [[

A simple and lightweight autojump tool

Usage:
    If the shell has been configured then:
    zua <pattern>...   This will match the pattern against the paths contained with $ZUA_DATA_FILE
                       and jump to the first match
    If using zua directly then:
    zua.lua [Command] [Options]

Commands:
    add <path>         Adds the provided path to the data file.
    init <shell>       Outputs the required shell code to be added to shell config.
                       "fish" and "zsh" are currently supported.
    jump               Matches the patterns to a path prints a cd command for that path.
    edit               Open up the data file in $EDITOR.

Options:
    --case             Make the pattern case sensitive.
    --help             Prints help information.
    --name             Set the name of the command generated by init. ('cd' not supported)
    --nojump           Avoid generating the "zua" function in the shell. Useful if you only want the path adding alongside your own picker.
    --patternmatch     By default zua will escape ( ) . % + - * ? [ ^ $ and match these literally.
                       This option will disable this and utilise Lua pattern matching.
    --version          Prints version information.

ENVIRONMENT VARIABLES:
       ZUA_DEFAULT_ARGS
           Specifies the args to be provided every time zua is called through the shell function.
       ZUA_DATA_FILE
           Specifies the path to the data file to store paths in.

https://github.com/Shivix/zua.lua
]]

local fish_jump = [[
function FUNCTION_NAME -d "A simple and predictable smart cd"
    if test "$argv" = -; or test "$argv" = ..
        cd $argv
        return
    end
    if test -z "$argv"
        cd
        return
    end
    eval (zua.lua jump $argv $ZUA_DEFAULT_ARGS)
end
]]
local fish_add = [[
function _zua_add --on-variable PWD
    zua.lua add $PWD/
end
if not set -q ZUA_DATA_FILE
    set -gx ZUA_DATA_FILE $HOME/.local/state/zua/data
end
]]

local zsh_jump = [[
FUNCTION_NAME() {
    if [[ "$@" = "-" || "$@" = ".." ]]
                .. "]]"
                .. [[; then
        cd "$@"
        return
    fi
    if [[ -z "$@" ]]
                .. "]]"
                .. [[; then
        cd
        return
    fi
    eval $(zua.lua jump $@ $ZUA_DEFAULT_ARGS)
}
]]
local zsh_add = [[
_zua_add() {
    zua.lua add $PWD/
}
chpwd_functions+=(_zua_add)
export ZUA_DATA_FILE="${ZUA_DATA_FILE:=$HOME/.local/state/zua/data}"
]]

local function initialize(patterns, opts)
    if #patterns ~= 1 then
        io.stderr:write("init requires a single arg (the shell name)\n")
        return
    end
    if opts.name == "cd" then
        io.stderr:write("zua does not support setting the command name to cd\n")
        return
    end
    local shell = patterns[1]
    local shell_code = ""
    local function_name = (opts.name or "zua")
    if shell == "fish" then
        if not opts.nojump then
            shell_code = fish_jump:gsub("FUNCTION_NAME", function_name)
        end
        shell_code = shell_code .. fish_add
        return shell_code
    elseif shell == "zsh" then
        if not opts.nojump then
            shell_code = zsh_jump:gsub("FUNCTION_NAME", function_name)
        end
        shell_code = shell_code .. zsh_add
    else
        io.stderr:write("shell not supported: " .. shell .. "\n")
        return
    end
    return shell_code
end

local function add_path(patterns)
    assert(#patterns == 1)
    local path = patterns[1]
    local data = io.open(DATA_FILE, "r")
    if data == nil then
        error("file at $ZUA_DATA_FILE does not exist")
    end
    for line in data:lines() do
        if line == path then
            return
        end
    end
    data:close()
    data = assert(io.open(DATA_FILE, "a+"))
    data:write(path .. "\n")
    data:close()
    os.execute("sort " .. DATA_FILE .. " -o " .. DATA_FILE)
end

local function delete_path(path)
    local lines = {}
    local file = assert(io.open(DATA_FILE, "r"))
    for line in file:lines() do
        if line ~= path then
            table.insert(lines, line)
        end
    end
    file:close()
    file = assert(io.open(DATA_FILE, "w"))
    for _, line in ipairs(lines) do
        file:write(line .. "\n")
    end
    file:close()
end

local function matches_all_patterns(line, patterns)
    for _, pattern in ipairs(patterns) do
        if not line:lower():find(pattern) then
            return false
        end
    end
    return true
end
local function last_pattern_matches_child_directory(line, pattern)
    local pos = line:find("/[^/]*/$")
    if pos == nil then
        return
    end
    return line:sub(pos):lower():find(pattern)
end

local function find_match(patterns, opts)
    -- Shell function should only use cd in this case.
    assert(#patterns ~= 0)
    local data <close> = io.open(DATA_FILE, "r")
    if data == nil then
        error("file at $ZUA_DATA_FILE does not exist")
    end

    if not opts.case then
        for i, pattern in ipairs(patterns) do
            patterns[i] = pattern:lower()
        end
    end
    if not opts.patternmatch then
        for i, pattern in ipairs(patterns) do
            -- Escape the magic characters and match them literally.
            patterns[i] = pattern:gsub("([%(%)%.%%%+%-%*%?%[%]%^%$])", "%%%1")
        end
    end

    ::rematch::
    local match
    for line in data:lines() do
        if matches_all_patterns(line, patterns) then
            if last_pattern_matches_child_directory(line, patterns[#patterns]) then
                match = line
                break
            end
            if match == nil then
                match = line
            end
        end
    end
    if match then
        -- Ensure that we only ever try to cd with a single string arg to avoid eval running any bad code.
        local file <close> = io.open(match, "r")
        if file == nil then
            delete_path(match)
            io.stderr:write("Deleting invalid path: " .. match .. "\n")
            goto rematch
        end
        return "'" .. match:gsub("'", "'\\''") .. "'"
    end
end

local function get_opt(arg_name, defined_opts)
    for long, opt in pairs(defined_opts) do
        if arg_name == long or arg_name == opt.short then
            opt.long = long
            return opt
        end
    end
    return nil
end

local function parse_args(defined_opts)
    local parsedArgs = {}
    local opts = {}
    local i = 1
    while i <= #arg do
        local current_arg = arg[i]
        local arg_name = current_arg:match("^%-%-?([^=]*)")
        if arg_name ~= nil then
            local opt = get_opt(arg_name, defined_opts)
            if opt == nil then
                io.stderr:write("Invalid option: " .. arg_name .. "\n")
                os.exit(1)
            end
            if opt.value then
                local value = current_arg:match("^%-%-?.-=(.*)$")
                if value == nil then
                    value = arg[i + 1]
                    if value == nil or value:match("^%-") then
                        io.stderr:write("Value expected for option: " .. arg_name .. "\n")
                        os.exit(1)
                    end
                    i = i + 1
                end
                opts[opt.long] = value
            else
                opts[opt.long] = true
            end
        else
            table.insert(parsedArgs, current_arg)
        end

        i = i + 1
    end
    return opts, parsedArgs
end

if #arg == 0 then
    io.stderr:write(help_msg)
    os.exit(1)
end

local opts, args = parse_args(options)

local cmd = args[1]
local patterns = { table.unpack(args, 2) }

if opts.help then
    if cmd == "jump" then
        -- Avoid trying to eval the help message.
        io.stderr:write(help_msg)
    else
        print(help_msg)
    end
elseif opts.version then
    print("echo zua.lua v" .. version)
elseif cmd == "add" then
    add_path(patterns)
elseif cmd == "edit" then
    os.execute(os.getenv("EDITOR") .. " " .. DATA_FILE)
elseif cmd == "init" then
    print(initialize(patterns, opts))
elseif cmd == "jump" then
    local match = find_match(patterns, opts)
    if match then
        print("cd " .. match)
    else
        io.stderr:write("No match found\n")
    end
else
    if cmd == "" then
        io.stderr:write(help_msg)
    else
        io.stderr:write("invalid command: " .. cmd .. "\n")
    end
end
