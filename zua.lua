#!/usr/bin/env lua

DATA_FILE = os.getenv("ZUA_DATA_FILE") or "~/.local/state/zua/data"
DATA_FILE = DATA_FILE:gsub("^~", assert(os.getenv("HOME")))

local options = {
    help = {
        short = "h",
        value = false,
    },
    version = {
        short = "v",
        value = false,
    },
    patternmatch = {
        short = "p",
        value = false,
    },
    case = {
        short = "c",
        value = false,
    },
    name = {
        short = "n",
        value = true,
    },
}

local version = "1.3.1"
local help_msg = [[
zua.lua ]] .. version .. [[

A simple and lightweight autojump tool

Usage:
    If the shell has been configured then:
    zua <pattern>...   This will match the pattern against the paths contained with $ZUA_DATA_FILE
                       and jump to the first match
    If using zua directly then:
    zua.lua [Command] [Options]

Commands:
    add <path>         Adds the provided path to the data file.
    init <shell>       Outputs the required shell code to be added to shell config.
                       "fish" and "zsh" are currently supported.
    jump               Matches the patterns to a path prints a cd command for that path.
    edit               Open up the data file in $EDITOR.

Options:
    --case             Make the pattern case sensitive.
    --help             Prints help information.
    --name             Set the name of the command generated by init. ('cd' not supported)
    --patternmatch     By default zua will escape ( ) . % + - * ? [ ^ $ and match these literally.
                       This option will disable this and utilise Lua pattern matching.
    --version          Prints version information.

ENVIRONMENT VARIABLES:
       ZUA_DEFAULT_ARGS
           Specifies the args to be provided every time zua is called through the shell function.
       ZUA_DATA_FILE
           Specifies the path to the data file to store paths in.

https://github.com/Shivix/zua.lua
]]

local function initialize(patterns, opts)
    if #patterns ~= 1 then
        io.stderr:write("init requires a single arg (the shell name)\n")
        return
    end
    if opts.name == "cd" then
        io.stderr:write("zua does not support setting the command name to cd\n")
        return
    end
    local shell = patterns[1]
    if shell == "fish" then
        return "function "
            .. (opts.name or "zua")
            .. [[ -d "A simple and predictable smart cd"
    if test "$argv" = -; or test "$argv" = ..
        cd $argv
        return
    end
    if test -z "$argv"
        cd
        return
    end
    eval (zua.lua jump $argv $ZUA_DEFAULT_ARGS)
end
function _zua_add --on-variable PWD
    zua.lua add $PWD/
end
if not set -q ZUA_DATA_FILE
    set -gx ZUA_DATA_FILE $HOME/.local/state/zua/data
end
]]
    elseif shell == "zsh" then
        return (opts.name or "zua")
            .. [[() {
    if [[ "$@" = "-" || "$@" = ".." ]]
            .. "]]"
            .. [[; then
        cd "$@"
        return
    fi
    if [[ -z "$@" ]]
            .. "]]"
            .. [[; then
        cd
        return
    fi
    eval $(zua.lua jump $@ $ZUA_DEFAULT_ARGS)
}
_zua_add() {
    zua.lua add $PWD/
}
chpwd_functions+=(_zua_add)
export ZUA_DATA_FILE="${ZUA_DATA_FILE:=$HOME/.local/state/zua/data}"
]]
    else
        io.stderr:write("shell not supported: " .. shell .. "\n")
        return
    end
end

local function add_path(patterns)
    local data = io.open(DATA_FILE, "r")
    if data == nil then
        error("file at $ZUA_DATA_FILE does not exist")
    end
    assert(#patterns == 1)
    local path = patterns[1]
    for line in data:lines() do
        if line == path then
            return
        end
    end
    data:close()
    data = assert(io.open(DATA_FILE, "a+"))
    data:write(path .. "\n")
end

local function matches_all_patterns(line, patterns)
    for _, pattern in ipairs(patterns) do
        if not line:lower():find(pattern) then
            return false
        end
    end
    return true
end

local function find_match(patterns, opts)
    -- Shell function should only use cd in this case.
    assert(#patterns ~= 0)
    local data <close> = io.open(DATA_FILE, "r")
    if data == nil then
        error("file at $ZUA_DATA_FILE does not exist")
    end

    if not opts.case then
        for i, pattern in ipairs(patterns) do
            patterns[i] = pattern:lower()
        end
    end
    if not opts.patternmatch then
        for i, pattern in ipairs(patterns) do
            -- Escape the magic characters and match them literally.
            patterns[i] = pattern:gsub("([%(%)%.%%%+%-%*%?%[%]%^%$])", "%%%1")
        end
    end

    for line in data:lines() do
        if matches_all_patterns(line, patterns) then
            -- TODO: Check if path exists, if not, delete it from data.
            -- Ensure that we only ever try to cd with a single string arg to avoid eval running any bad code.
            return "'" .. line:gsub("'", "'\\''") .. "'"
        end
    end
    return nil
end

local function get_opt(arg_name, defined_opts)
    for long, opt in pairs(defined_opts) do
        if arg_name == long or arg_name == opt.short then
            opt.long = long
            return opt
        end
    end
    return nil
end

local function parse_args(defined_opts)
    local parsedArgs = {}
    local opts = {}
    local i = 1
    while i <= #arg do
        local current_arg = arg[i]
        local arg_name = current_arg:match("^%-%-?([^=]*)")
        if arg_name ~= nil then
            local opt = get_opt(arg_name, defined_opts)
            if opt == nil then
                io.stderr:write("Invalid option: " .. arg_name .. "\n")
                os.exit(1)
            end
            if opt.value then
                local value = current_arg:match("^%-%-?.-=(.*)$")
                if value == nil then
                    value = arg[i + 1]
                    if value == nil or value:match("^%-") then
                        io.stderr:write("Value expected for option: " .. arg_name .. "\n")
                        os.exit(1)
                    end
                    i = i + 1
                end
                opts[opt.long] = value
            else
                opts[opt.long] = true
            end
        else
            table.insert(parsedArgs, current_arg)
        end

        i = i + 1
    end
    return opts, parsedArgs
end

if #arg == 0 then
    io.stderr:write(help_msg)
    os.exit(1)
end

local opts, args = parse_args(options)

local cmd = args[1]
local patterns = { table.unpack(args, 2) }

if opts.help then
    if cmd == "jump" then
        -- Avoid trying to eval the help message.
        io.stderr:write(help_msg)
    else
        print(help_msg)
    end
elseif opts.version then
    print("echo zua.lua v" .. version)
elseif cmd == "add" then
    add_path(patterns)
elseif cmd == "edit" then
    print(os.getenv("EDITOR") .. " " .. DATA_FILE)
elseif cmd == "init" then
    print(initialize(patterns, opts))
elseif cmd == "jump" then
    local match = find_match(patterns, opts)
    if match then
        print("cd " .. match)
    else
        io.stderr:write("No match found\n")
    end
else
    if cmd == "" then
        io.stderr:write(help_msg)
    else
        io.stderr:write("invalid command: " .. cmd .. "\n")
    end
end
